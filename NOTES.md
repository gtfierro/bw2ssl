## Running it

Prefix your apps with
```
LD_PRELOAD=./bw2ssl.so LD_LIBRARY_PATH=.
```

## Reading

It doesn't seem possible to intercept `read` when using the `LD_PRELOAD` in /bin/nc.

Following is the relevant part of `strace nc -l 8000`

```c
// we intercept this
socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
// we intercept this
bind(3, {sa_family=AF_INET, sin_port=htons(8000), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
// we intercept this
listen(3, 1)                            = 0
// we intercept this
accept(3, {sa_family=AF_INET, sin_port=htons(54064), sin_addr=inet_addr("127.0.0.1")}, [16]) = 4
// we intercept this
close(3)                                = 0
// we do NOT intercept this!
poll([{fd=4, events=POLLIN}, {fd=0, events=POLLIN}], 2, -1) = 1 ([{fd=4, revents=POLLIN}])
// OR THIS
read(4, "hello there\n", 2048)          = 12
// but this we do
write(1, "hello there\n", 12hello there
)           = 12
// but not this
poll([{fd=4, events=POLLIN}, {fd=0, events=POLLIN}], 2, -1
```

This would suggest that netcat calls some function that uses a symbol for
`poll` that is statically defined, so we can't intercept it by loading in a
dynamic object.

Using `ncat`, which is a newer version of netcat, we can intercept a call to `recv`, but
it uses a file descriptor that is probably generated by `select`

## Possible Solution

Focusing on `/bin/nc`, it calls poll on the fd returned from the call to `accept`, which we
*can* intercept. So, we return a dummy fd from accept, subscribe to the BW port, and when
we receive data on that port, we "signal" the dummy fd so that `poll` works as `nc` expects.
This would probably also work for `select`.

So: how do we create a dummy file descriptor? Worth trying `shm_open` to create a shared 
memory region -- this is the fd we return from `accept`. When we receive data, we write
to it.
ALSO maybe try mkfifo

We will probably fork in order to subscribe.

Also look at: https://blog.gopheracademy.com/advent-2015/libc-hooking-go-shared-libraries/


## Left to do

**write** seems to work well enough (`ssize_t write(int fd, const void *buf, size_t count)`)

Also need to do:
* send:
  ```
  ssize_t send(int sockfd, const void *buf, size_t len, int flags)
  ```
* sendto
    ```
    ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                   const struct sockaddr *dest_addr, socklen_t addrlen);
    ```
* sendmsg
    ```
    ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
    ```
